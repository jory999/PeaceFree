/*
* guzhoudiaoke@126.com
* 2015-09-13 23:35
*/

#include "mouse.h"
#include "graphics.h"
#include "i8259a.h"
#include "dmfont.h"
#include "queue.h"

static mouse_data_t mouse_data;
static queue_t mouse_queue;
static s32 mouse_x_pre, mouse_y_pre;
static s32 mouse_x, mouse_y;
static rgb_t p_img_under_mouse[MOUSE_IMG_HEIGHT * MOUSE_IMG_WIDTH];
static u8 p_mouse_pointer_img[MOUSE_IMG_HEIGHT * MOUSE_IMG_WIDTH] = { 
    /*00*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*01*/ 0xff, 0xff, 0x78, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*02*/ 0xff, 0xff, 0x00, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*03*/ 0xff, 0xff, 0x00, 0x1b, 0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*04*/ 0xff, 0xff, 0x00, 0xdc, 0x16, 0x76, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*05*/ 0xff, 0xff, 0x00, 0xfe, 0xd6, 0x13, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*06*/ 0xff, 0xff, 0x00, 0xfa, 0xfe, 0xd0, 0x11, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*07*/ 0xff, 0xff, 0x00, 0xf7, 0xfe, 0xf3, 0xc9, 0x0f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*08*/ 0xff, 0xff, 0x00, 0xf3, 0xfa, 0xf1, 0xf1, 0xc3, 0x10, 0x97, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*09*/ 0xff, 0xff, 0x00, 0xf0, 0xf7, 0xfe, 0xfe, 0xf2, 0xbb, 0x0f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
    /*10*/ 0xff, 0xff, 0x00, 0xec, 0xf4, 0xfb, 0xf3, 0xf1, 0xf1, 0xb4, 0x10, 0xa6, 0xff, 0xff, 0xff, 0xff, 
    /*11*/ 0xff, 0xff, 0x00, 0xe9, 0xf0, 0xf7, 0xfe, 0xfd, 0xf1, 0xf1, 0xaa, 0x11, 0xae, 0xff, 0xff, 0xff, 
    /*12*/ 0xff, 0xff, 0x00, 0xe6, 0xed, 0xf4, 0xfb, 0xfe, 0xfe, 0xfe, 0xfb, 0xa2, 0x13, 0xb4, 0xff, 0xff, 
    /*13*/ 0xff, 0xff, 0x00, 0xe2, 0xe9, 0xf0, 0xf7, 0xfd, 0x2d, 0x0b, 0x0b, 0x0b, 0x01, 0x13, 0xc5, 0xff, 
    /*14*/ 0xff, 0xff, 0x00, 0xdf, 0xe6, 0xd7, 0x9c, 0xfb, 0x90, 0x2a, 0x95, 0xa4, 0xa6, 0xad, 0xce, 0xff, 
    /*15*/ 0xff, 0xff, 0x00, 0xdb, 0xca, 0x1e, 0x0f, 0xeb, 0xf5, 0x13, 0x99, 0xe6, 0xff, 0xff, 0xff, 0xff, 
    /*16*/ 0xff, 0xff, 0x00, 0xc0, 0x1b, 0x4d, 0x37, 0x7e, 0xfb, 0x80, 0x3e, 0xe5, 0xff, 0xff, 0xff, 0xff, 
    /*17*/ 0xff, 0xff, 0x00, 0x19, 0x53, 0xbb, 0xb1, 0x12, 0xed, 0xef, 0x0f, 0xb2, 0xff, 0xff, 0xff, 0xff, 
    /*18*/ 0xff, 0xff, 0x00, 0x5d, 0xbe, 0xff, 0xff, 0x42, 0x82, 0xfc, 0x3e, 0x76, 0xee, 0xff, 0xff, 0xff, 
    /*19*/ 0xff, 0xff, 0x81, 0xcc, 0xff, 0xff, 0xff, 0xbd, 0x0f, 0x43, 0x14, 0x91, 0xee, 0xff, 0xff, 0xff, 
    /*20*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb4, 0x6f, 0x9a, 0xd7, 0xff, 0xff, 0xff, 0xff, 
    /*21*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
};

u8	 io_inb (u16 port);
void io_outb(u8 value, u16 port);
void io_cli();
void io_sti();


void wait_kb_controller_ready()
{
    while (io_inb(KB_PORT_STATE) & KB_STATE_SEND_NOT_READY)
    ;
}

void init_kb_controller()
{
    wait_kb_controller_ready();
    io_outb(KB_CMD_SET_MODE, KB_PORT_CMD);

    wait_kb_controller_ready();
    io_outb(KB_CONTROLLER_MODE, KB_PORT_DATA);
}

static void enable_mouse()
{
    wait_kb_controller_ready();
    io_outb(KB_CMD_SENDTO_MOUSE, KB_PORT_CMD);

    wait_kb_controller_ready();
    io_outb(MOUSE_CMD_ENABLE, KB_PORT_DATA);
}

void do_mouse()
{
    u8 data = io_inb(0x60);
    if (!is_queue_full(&mouse_queue))				/* 若队列未满则入队，否则放弃 */
    {
        en_queue(&mouse_queue, data);
    }

    io_outb(0x20, 0x20);
    io_outb(0x20, 0xa0);
}

void init_mouse()
{
    mouse_x = 512, mouse_y = 384;
    mouse_x_pre = 0, mouse_y_pre = 0;
    mouse_data.phase = 0;

    init_kb_controller();
    enable_mouse();

    set_irq(IRQ_MOUSE, (u32)&do_mouse);			/* 设置中断处理程序 */
    enable_irq(IRQ_MOUSE);						/* 通知8259A开启键盘中断 */
}

static void draw_mouse_info()
{
    const u32 x = 10, y = 10;
    rect_t rect = { x, y, 152, 16 };
    rgb_t color_bk = { 0xff, 0xee, 0xdd };
    fill_rectangle(rect, color_bk);

    rgb_t color = { 0xff, 0x00, 0x22 };
    draw_string("mouse (", x, y, color);
    draw_dec(mouse_x,      x + 8* 7, y, color);
    draw_string(",",       x + 8*11, y, color);
    draw_dec(mouse_y,      x + 8*12, y, color);
    draw_string(")",       x + 8*15, y, color);
}

static void save_img_under_mouse()
{
    /* save img under mouse */
    for (s32 y = 0; y < MOUSE_IMG_HEIGHT; ++y)
    {
        for (s32 x = 0; x < MOUSE_IMG_WIDTH; ++x)
        {
            p_img_under_mouse[y*MOUSE_IMG_WIDTH + x] = get_pixel(mouse_x + x, mouse_y + y);
        }
    }
}

void draw_mouse()
{
    save_img_under_mouse();

    /* draw mouse img */
    for (s32 y = 0; y < MOUSE_IMG_HEIGHT; ++y)
    {
        for (s32 x = 0; x < MOUSE_IMG_WIDTH; ++x)
        {
            u8 color = p_mouse_pointer_img[y*MOUSE_IMG_WIDTH + x];
            if (color != 0xff)
            set_pixel(mouse_x + x, mouse_y + y, color, color, color);
        }
    }
}

static void mouse_move()
{
    /* restore old img under mouse */
    for (s32 y = 0; y < MOUSE_IMG_HEIGHT; ++y)
    {
        for (s32 x = 0; x < MOUSE_IMG_WIDTH; ++x)
        {
            rgb_t* rgb = &p_img_under_mouse[y*MOUSE_IMG_WIDTH + x];
            set_pixel(mouse_x_pre + x, mouse_y_pre + y, rgb->r, rgb->g, rgb->b);
        }
    }

    draw_mouse();
}

void mouse_data_process(u8 data)
{
    if (mouse_data.phase == 0)
    {
        if (data == 0xfa)
        mouse_data.phase = 1;
    }
    else if (mouse_data.phase == 1)
    {
        if ((data & 0xc8) != 0x08)
        return;

        mouse_data.data[0] = data;
        mouse_data.phase = 2;
    }
    else if (mouse_data.phase == 2)
    {
        mouse_data.data[1] = data;
        mouse_data.phase = 3;
    }
    else if (mouse_data.phase == 3)
    {
        mouse_data.data[2] = data;
        mouse_data.phase = 1;

        mouse_data.button = mouse_data.data[0] & 0x07;
        mouse_data.x = mouse_data.data[1];
        mouse_data.y = mouse_data.data[2];

        if ((mouse_data.data[0] & 0x10) != 0)
        {
            mouse_data.x |= 0xffffff00;
        }
        if ((mouse_data.data[0] & 0x20) != 0)
        {
            mouse_data.y |= 0xffffff00;
        }
        mouse_data.y = -mouse_data.y;

        mouse_x_pre = mouse_x;
        mouse_y_pre = mouse_y;
        mouse_x += mouse_data.x;
        mouse_y += mouse_data.y;
        if (mouse_x < 0) mouse_x = 0;
        if (mouse_x >= 1024-MOUSE_IMG_WIDTH) mouse_x = 1024-MOUSE_IMG_WIDTH-1;
        if (mouse_y < 0) mouse_y = 0;
        if (mouse_y >= 768-MOUSE_IMG_HEIGHT) mouse_y = 768-MOUSE_IMG_HEIGHT-1;

        if (mouse_x != mouse_x_pre || mouse_y != mouse_y_pre)
        {
            draw_mouse_info();
            mouse_move();
        }
    }
}

void mouse_read()
{
    if (!is_queue_empty(&mouse_queue))
    {
        u8 data;
        io_cli();
        de_queue(&mouse_queue, &data);
        io_sti();

        mouse_data_process(data);
    }
}

